// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v2 "github.com/crossplane/crossplane-runtime/v2/apis/common/v2"
)

type CurrencyOptionsInitParameters struct {

	// String. Three-letter ISO currency code, in lowercase - supported currencies.
	// Each currency must be a three-letter ISO currency code and a supported currency
	Currency *string `json:"currency,omitempty" tf:"currency,omitempty"`

	// List(Resource). When set,
	// provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
	// See details in Custom Unit Amount.
	// When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links
	CustomUnitAmount []CustomUnitAmountInitParameters `json:"customUnitAmount,omitempty" tf:"custom_unit_amount,omitempty"`

	// String. Only required if a default tax behavior was not provided in the Stripe Tax settings.
	// Specifies whether the price is considered inclusive of taxes or exclusive of taxes.
	// One of inclusive, exclusive, or unspecified.
	// Once specified as either inclusive or exclusive, it cannot be changed.
	// Only required if a default tax behavior was not provided in the Stripe Tax settings. Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
	TaxBehavior *string `json:"taxBehavior,omitempty" tf:"tax_behavior,omitempty"`

	// List(Resource). Each element represents a pricing tier.
	// This parameter requires billing_scheme to be set to tiered. This resource can be used more than once and follows
	// the same fields as the root tiers block
	// Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the documentation for billing_scheme.
	Tiers []TiersInitParameters `json:"tiers,omitempty" tf:"tiers,omitempty"`

	// Int. A positive integer in cents (or -1 for a free price) representing how much to charge.
	// A positive integer in cents (or -1 for a free price) representing how much to charge.
	UnitAmount *float64 `json:"unitAmount,omitempty" tf:"unit_amount,omitempty"`

	// Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
	// decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	// Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	UnitAmountDecimal *float64 `json:"unitAmountDecimal,omitempty" tf:"unit_amount_decimal,omitempty"`
}

type CurrencyOptionsObservation struct {

	// String. Three-letter ISO currency code, in lowercase - supported currencies.
	// Each currency must be a three-letter ISO currency code and a supported currency
	Currency *string `json:"currency,omitempty" tf:"currency,omitempty"`

	// List(Resource). When set,
	// provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
	// See details in Custom Unit Amount.
	// When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links
	CustomUnitAmount []CustomUnitAmountObservation `json:"customUnitAmount,omitempty" tf:"custom_unit_amount,omitempty"`

	// String. Only required if a default tax behavior was not provided in the Stripe Tax settings.
	// Specifies whether the price is considered inclusive of taxes or exclusive of taxes.
	// One of inclusive, exclusive, or unspecified.
	// Once specified as either inclusive or exclusive, it cannot be changed.
	// Only required if a default tax behavior was not provided in the Stripe Tax settings. Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
	TaxBehavior *string `json:"taxBehavior,omitempty" tf:"tax_behavior,omitempty"`

	// List(Resource). Each element represents a pricing tier.
	// This parameter requires billing_scheme to be set to tiered. This resource can be used more than once and follows
	// the same fields as the root tiers block
	// Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the documentation for billing_scheme.
	Tiers []TiersObservation `json:"tiers,omitempty" tf:"tiers,omitempty"`

	// Int. A positive integer in cents (or -1 for a free price) representing how much to charge.
	// A positive integer in cents (or -1 for a free price) representing how much to charge.
	UnitAmount *float64 `json:"unitAmount,omitempty" tf:"unit_amount,omitempty"`

	// Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
	// decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	// Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	UnitAmountDecimal *float64 `json:"unitAmountDecimal,omitempty" tf:"unit_amount_decimal,omitempty"`
}

type CurrencyOptionsParameters struct {

	// String. Three-letter ISO currency code, in lowercase - supported currencies.
	// Each currency must be a three-letter ISO currency code and a supported currency
	// +kubebuilder:validation:Optional
	Currency *string `json:"currency" tf:"currency,omitempty"`

	// List(Resource). When set,
	// provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
	// See details in Custom Unit Amount.
	// When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links
	// +kubebuilder:validation:Optional
	CustomUnitAmount []CustomUnitAmountParameters `json:"customUnitAmount,omitempty" tf:"custom_unit_amount,omitempty"`

	// String. Only required if a default tax behavior was not provided in the Stripe Tax settings.
	// Specifies whether the price is considered inclusive of taxes or exclusive of taxes.
	// One of inclusive, exclusive, or unspecified.
	// Once specified as either inclusive or exclusive, it cannot be changed.
	// Only required if a default tax behavior was not provided in the Stripe Tax settings. Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
	// +kubebuilder:validation:Optional
	TaxBehavior *string `json:"taxBehavior,omitempty" tf:"tax_behavior,omitempty"`

	// List(Resource). Each element represents a pricing tier.
	// This parameter requires billing_scheme to be set to tiered. This resource can be used more than once and follows
	// the same fields as the root tiers block
	// Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the documentation for billing_scheme.
	// +kubebuilder:validation:Optional
	Tiers []TiersParameters `json:"tiers,omitempty" tf:"tiers,omitempty"`

	// Int. A positive integer in cents (or -1 for a free price) representing how much to charge.
	// A positive integer in cents (or -1 for a free price) representing how much to charge.
	// +kubebuilder:validation:Optional
	UnitAmount *float64 `json:"unitAmount,omitempty" tf:"unit_amount,omitempty"`

	// Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
	// decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	// Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	// +kubebuilder:validation:Optional
	UnitAmountDecimal *float64 `json:"unitAmountDecimal,omitempty" tf:"unit_amount_decimal,omitempty"`
}

type CustomUnitAmountInitParameters struct {

	// Bool. Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount.
	// Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Int. The maximum unit amount the customer can specify for this item.
	// The maximum unit amount the customer can specify for this item.
	Maximum *float64 `json:"maximum,omitempty" tf:"maximum,omitempty"`

	// Int. The minimum unit amount the customer can specify for this item.
	// Must be at least the minimum charge amount.
	// The minimum unit amount the customer can specify for this item. Must be at least the minimum charge amount.
	Minimum *float64 `json:"minimum,omitempty" tf:"minimum,omitempty"`

	// Int. The starting unit amount which can be updated by the customer.
	// The starting unit amount which can be updated by the customer.
	Preset *float64 `json:"preset,omitempty" tf:"preset,omitempty"`
}

type CustomUnitAmountObservation struct {

	// Bool. Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount.
	// Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Int. The maximum unit amount the customer can specify for this item.
	// The maximum unit amount the customer can specify for this item.
	Maximum *float64 `json:"maximum,omitempty" tf:"maximum,omitempty"`

	// Int. The minimum unit amount the customer can specify for this item.
	// Must be at least the minimum charge amount.
	// The minimum unit amount the customer can specify for this item. Must be at least the minimum charge amount.
	Minimum *float64 `json:"minimum,omitempty" tf:"minimum,omitempty"`

	// Int. The starting unit amount which can be updated by the customer.
	// The starting unit amount which can be updated by the customer.
	Preset *float64 `json:"preset,omitempty" tf:"preset,omitempty"`
}

type CustomUnitAmountParameters struct {

	// Bool. Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount.
	// Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`

	// Int. The maximum unit amount the customer can specify for this item.
	// The maximum unit amount the customer can specify for this item.
	// +kubebuilder:validation:Optional
	Maximum *float64 `json:"maximum,omitempty" tf:"maximum,omitempty"`

	// Int. The minimum unit amount the customer can specify for this item.
	// Must be at least the minimum charge amount.
	// The minimum unit amount the customer can specify for this item. Must be at least the minimum charge amount.
	// +kubebuilder:validation:Optional
	Minimum *float64 `json:"minimum,omitempty" tf:"minimum,omitempty"`

	// Int. The starting unit amount which can be updated by the customer.
	// The starting unit amount which can be updated by the customer.
	// +kubebuilder:validation:Optional
	Preset *float64 `json:"preset,omitempty" tf:"preset,omitempty"`
}

type PriceCustomUnitAmountInitParameters struct {

	// Bool. Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount.
	// Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Int. The maximum unit amount the customer can specify for this item.
	// The maximum unit amount the customer can specify for this item.
	Maximum *float64 `json:"maximum,omitempty" tf:"maximum,omitempty"`

	// Int. The minimum unit amount the customer can specify for this item.
	// Must be at least the minimum charge amount.
	// The minimum unit amount the customer can specify for this item. Must be at least the minimum charge amount.
	Minimum *float64 `json:"minimum,omitempty" tf:"minimum,omitempty"`

	// Int. The starting unit amount which can be updated by the customer.
	// The starting unit amount which can be updated by the customer.
	Preset *float64 `json:"preset,omitempty" tf:"preset,omitempty"`
}

type PriceCustomUnitAmountObservation struct {

	// Bool. Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount.
	// Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Int. The maximum unit amount the customer can specify for this item.
	// The maximum unit amount the customer can specify for this item.
	Maximum *float64 `json:"maximum,omitempty" tf:"maximum,omitempty"`

	// Int. The minimum unit amount the customer can specify for this item.
	// Must be at least the minimum charge amount.
	// The minimum unit amount the customer can specify for this item. Must be at least the minimum charge amount.
	Minimum *float64 `json:"minimum,omitempty" tf:"minimum,omitempty"`

	// Int. The starting unit amount which can be updated by the customer.
	// The starting unit amount which can be updated by the customer.
	Preset *float64 `json:"preset,omitempty" tf:"preset,omitempty"`
}

type PriceCustomUnitAmountParameters struct {

	// Bool. Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount.
	// Pass in true to enable custom_unit_amount, otherwise omit custom_unit_amount
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`

	// Int. The maximum unit amount the customer can specify for this item.
	// The maximum unit amount the customer can specify for this item.
	// +kubebuilder:validation:Optional
	Maximum *float64 `json:"maximum,omitempty" tf:"maximum,omitempty"`

	// Int. The minimum unit amount the customer can specify for this item.
	// Must be at least the minimum charge amount.
	// The minimum unit amount the customer can specify for this item. Must be at least the minimum charge amount.
	// +kubebuilder:validation:Optional
	Minimum *float64 `json:"minimum,omitempty" tf:"minimum,omitempty"`

	// Int. The starting unit amount which can be updated by the customer.
	// The starting unit amount which can be updated by the customer.
	// +kubebuilder:validation:Optional
	Preset *float64 `json:"preset,omitempty" tf:"preset,omitempty"`
}

type PriceInitParameters struct {

	// Bool. Whether the price can be used for new purchases. Defaults to true.
	// Whether the price can be used for new purchases. Defaults to true.
	Active *bool `json:"active,omitempty" tf:"active,omitempty"`

	// String. Describes how to compute the price per period. Either per_unit or tiered
	// . per_unit indicates that the fixed amount (specified in unit_amount or unit_amount_decimal) will be charged per
	// unit in quantity (for prices with usage_type=licensed), or per unit of total usage (for prices
	// with usage_type=metered). tiered indicates that the unit pricing will be computed using a tiering strategy as
	// defined using the tiers and tiers_mode attributes.
	// Describes how to compute the price per period. Either per_unit or tiered. per_unit indicates that the fixed amount (specified in unit_amount or unit_amount_decimal) will be charged per unit in quantity (for prices with usage_type=licensed), or per unit of total usage (for prices with usage_type=metered). tiered indicates that the unit pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.
	BillingScheme *string `json:"billingScheme,omitempty" tf:"billing_scheme,omitempty"`

	// String. Three-letter ISO currency code, in lowercase - supported currencies.
	// Three-letter ISO currency code, in lowercase.
	Currency *string `json:"currency,omitempty" tf:"currency,omitempty"`

	// List(Resource). Prices defined in each available currency option. For details
	// of individual arguments see Currency Options.
	// Prices defined in each available currency option. Each key must be a three-letter ISO currency code and a supported currency
	CurrencyOptions []CurrencyOptionsInitParameters `json:"currencyOptions,omitempty" tf:"currency_options,omitempty"`

	// List(Resource). When set, provides configuration for the amount to be adjusted by
	// the customer during Checkout Sessions and Payment Links.
	// For individual fields see Custom Unit Amount.
	// When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links
	CustomUnitAmount []PriceCustomUnitAmountInitParameters `json:"customUnitAmount,omitempty" tf:"custom_unit_amount,omitempty"`

	// String. A lookup key used to retrieve prices dynamically from a static string.
	// A lookup key used to retrieve prices dynamically from a static string.
	LookupKey *string `json:"lookupKey,omitempty" tf:"lookup_key,omitempty"`

	// Map(String). Set of key-value pairs that you can attach to an object. This can be useful for
	// storing additional information about the object in a structured format.
	// Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
	// +mapType=granular
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// String. A brief description of the price, hidden from customers.
	// A brief description of the price, hidden from customers.
	Nickname *string `json:"nickname,omitempty" tf:"nickname,omitempty"`

	// String. The ID of the product that this price will belong to.
	// The ID of the product that this price will belong to.
	Product *string `json:"product,omitempty" tf:"product,omitempty"`

	// List(Resource). The recurring components of a price such as interval and usage_type. For
	// details of individual arguments see Recurring.
	// The recurring components of a price such as interval and usage_type.
	Recurring []RecurringInitParameters `json:"recurring,omitempty" tf:"recurring,omitempty"`

	// String. Specifies whether the price is considered inclusive of taxes or exclusive of
	// taxes. One of inclusive, exclusive, or unspecified. Once specified as either inclusive or exclusive, it
	// cannot be changed, default is unspecified.
	// Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
	TaxBehavior *string `json:"taxBehavior,omitempty" tf:"tax_behavior,omitempty"`

	// List(Resource). Each element represents a pricing tier. This parameter requires billing_scheme
	// to be set to tiered. See also the documentation for billing_scheme. For details of individual arguments
	// see Tiers.
	// Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the documentation for billing_scheme.
	Tiers []PriceTiersInitParameters `json:"tiers,omitempty" tf:"tiers,omitempty"`

	// String. Defines if the tiering price should be graduated
	// or volume based. In volume-based tiering, the maximum quantity within a period determines the per-unit price,
	// in graduated tiering pricing can successively change as the quantity grows.
	// Defines if the tiering price should be graduated or volume based. In volume-based tiering, the maximum quantity within a period determines the per unit price, in graduated tiering pricing can successively change as the quantity grows.
	TiersMode *string `json:"tiersMode,omitempty" tf:"tiers_mode,omitempty"`

	// Bool. If set to true, will atomically remove the lookup key from the existing
	// price, and assign it to this price.
	// If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
	TransferLookupKey *bool `json:"transferLookupKey,omitempty" tf:"transfer_lookup_key,omitempty"`

	// List(Resource). Apply a transformation to the reported usage or set quantity before
	// computing the billed price. Cannot be combined with tiers. For details of individual arguments
	// see Transform Quantity.
	// Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with tiers
	TransformQuantity []TransformQuantityInitParameters `json:"transformQuantity,omitempty" tf:"transform_quantity,omitempty"`

	// Int. A positive integer in cents (or -1 for a free
	// price) representing how much to charge.
	// A positive integer in cents (or -1 for a free price) representing how much to charge.
	UnitAmount *float64 `json:"unitAmount,omitempty" tf:"unit_amount,omitempty"`

	// Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
	// decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	// Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set
	UnitAmountDecimal *float64 `json:"unitAmountDecimal,omitempty" tf:"unit_amount_decimal,omitempty"`
}

type PriceObservation struct {

	// Bool. Whether the price can be used for new purchases. Defaults to true.
	// Whether the price can be used for new purchases. Defaults to true.
	Active *bool `json:"active,omitempty" tf:"active,omitempty"`

	// String. Describes how to compute the price per period. Either per_unit or tiered
	// . per_unit indicates that the fixed amount (specified in unit_amount or unit_amount_decimal) will be charged per
	// unit in quantity (for prices with usage_type=licensed), or per unit of total usage (for prices
	// with usage_type=metered). tiered indicates that the unit pricing will be computed using a tiering strategy as
	// defined using the tiers and tiers_mode attributes.
	// Describes how to compute the price per period. Either per_unit or tiered. per_unit indicates that the fixed amount (specified in unit_amount or unit_amount_decimal) will be charged per unit in quantity (for prices with usage_type=licensed), or per unit of total usage (for prices with usage_type=metered). tiered indicates that the unit pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.
	BillingScheme *string `json:"billingScheme,omitempty" tf:"billing_scheme,omitempty"`

	// String. Three-letter ISO currency code, in lowercase - supported currencies.
	// Three-letter ISO currency code, in lowercase.
	Currency *string `json:"currency,omitempty" tf:"currency,omitempty"`

	// List(Resource). Prices defined in each available currency option. For details
	// of individual arguments see Currency Options.
	// Prices defined in each available currency option. Each key must be a three-letter ISO currency code and a supported currency
	CurrencyOptions []CurrencyOptionsObservation `json:"currencyOptions,omitempty" tf:"currency_options,omitempty"`

	// List(Resource). When set, provides configuration for the amount to be adjusted by
	// the customer during Checkout Sessions and Payment Links.
	// For individual fields see Custom Unit Amount.
	// When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links
	CustomUnitAmount []PriceCustomUnitAmountObservation `json:"customUnitAmount,omitempty" tf:"custom_unit_amount,omitempty"`

	// String. The unique identifier for the object.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// String. A lookup key used to retrieve prices dynamically from a static string.
	// A lookup key used to retrieve prices dynamically from a static string.
	LookupKey *string `json:"lookupKey,omitempty" tf:"lookup_key,omitempty"`

	// Map(String). Set of key-value pairs that you can attach to an object. This can be useful for
	// storing additional information about the object in a structured format.
	// Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
	// +mapType=granular
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// String. A brief description of the price, hidden from customers.
	// A brief description of the price, hidden from customers.
	Nickname *string `json:"nickname,omitempty" tf:"nickname,omitempty"`

	// String. The ID of the product that this price will belong to.
	// The ID of the product that this price will belong to.
	Product *string `json:"product,omitempty" tf:"product,omitempty"`

	// List(Resource). The recurring components of a price such as interval and usage_type. For
	// details of individual arguments see Recurring.
	// The recurring components of a price such as interval and usage_type.
	Recurring []RecurringObservation `json:"recurring,omitempty" tf:"recurring,omitempty"`

	// String. Specifies whether the price is considered inclusive of taxes or exclusive of
	// taxes. One of inclusive, exclusive, or unspecified. Once specified as either inclusive or exclusive, it
	// cannot be changed, default is unspecified.
	// Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
	TaxBehavior *string `json:"taxBehavior,omitempty" tf:"tax_behavior,omitempty"`

	// List(Resource). Each element represents a pricing tier. This parameter requires billing_scheme
	// to be set to tiered. See also the documentation for billing_scheme. For details of individual arguments
	// see Tiers.
	// Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the documentation for billing_scheme.
	Tiers []PriceTiersObservation `json:"tiers,omitempty" tf:"tiers,omitempty"`

	// String. Defines if the tiering price should be graduated
	// or volume based. In volume-based tiering, the maximum quantity within a period determines the per-unit price,
	// in graduated tiering pricing can successively change as the quantity grows.
	// Defines if the tiering price should be graduated or volume based. In volume-based tiering, the maximum quantity within a period determines the per unit price, in graduated tiering pricing can successively change as the quantity grows.
	TiersMode *string `json:"tiersMode,omitempty" tf:"tiers_mode,omitempty"`

	// Bool. If set to true, will atomically remove the lookup key from the existing
	// price, and assign it to this price.
	// If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
	TransferLookupKey *bool `json:"transferLookupKey,omitempty" tf:"transfer_lookup_key,omitempty"`

	// List(Resource). Apply a transformation to the reported usage or set quantity before
	// computing the billed price. Cannot be combined with tiers. For details of individual arguments
	// see Transform Quantity.
	// Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with tiers
	TransformQuantity []TransformQuantityObservation `json:"transformQuantity,omitempty" tf:"transform_quantity,omitempty"`

	// String. One of one_time or recurring depending on whether the price is for a one-time purchase or a
	// recurring (subscription) purchase.
	// One of one_time or recurring depending on whether the price is for a one-time purchase or a recurring (subscription) purchase
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// Int. A positive integer in cents (or -1 for a free
	// price) representing how much to charge.
	// A positive integer in cents (or -1 for a free price) representing how much to charge.
	UnitAmount *float64 `json:"unitAmount,omitempty" tf:"unit_amount,omitempty"`

	// Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
	// decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	// Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set
	UnitAmountDecimal *float64 `json:"unitAmountDecimal,omitempty" tf:"unit_amount_decimal,omitempty"`
}

type PriceParameters struct {

	// Bool. Whether the price can be used for new purchases. Defaults to true.
	// Whether the price can be used for new purchases. Defaults to true.
	// +kubebuilder:validation:Optional
	Active *bool `json:"active,omitempty" tf:"active,omitempty"`

	// String. Describes how to compute the price per period. Either per_unit or tiered
	// . per_unit indicates that the fixed amount (specified in unit_amount or unit_amount_decimal) will be charged per
	// unit in quantity (for prices with usage_type=licensed), or per unit of total usage (for prices
	// with usage_type=metered). tiered indicates that the unit pricing will be computed using a tiering strategy as
	// defined using the tiers and tiers_mode attributes.
	// Describes how to compute the price per period. Either per_unit or tiered. per_unit indicates that the fixed amount (specified in unit_amount or unit_amount_decimal) will be charged per unit in quantity (for prices with usage_type=licensed), or per unit of total usage (for prices with usage_type=metered). tiered indicates that the unit pricing will be computed using a tiering strategy as defined using the tiers and tiers_mode attributes.
	// +kubebuilder:validation:Optional
	BillingScheme *string `json:"billingScheme,omitempty" tf:"billing_scheme,omitempty"`

	// String. Three-letter ISO currency code, in lowercase - supported currencies.
	// Three-letter ISO currency code, in lowercase.
	// +kubebuilder:validation:Optional
	Currency *string `json:"currency,omitempty" tf:"currency,omitempty"`

	// List(Resource). Prices defined in each available currency option. For details
	// of individual arguments see Currency Options.
	// Prices defined in each available currency option. Each key must be a three-letter ISO currency code and a supported currency
	// +kubebuilder:validation:Optional
	CurrencyOptions []CurrencyOptionsParameters `json:"currencyOptions,omitempty" tf:"currency_options,omitempty"`

	// List(Resource). When set, provides configuration for the amount to be adjusted by
	// the customer during Checkout Sessions and Payment Links.
	// For individual fields see Custom Unit Amount.
	// When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links
	// +kubebuilder:validation:Optional
	CustomUnitAmount []PriceCustomUnitAmountParameters `json:"customUnitAmount,omitempty" tf:"custom_unit_amount,omitempty"`

	// String. A lookup key used to retrieve prices dynamically from a static string.
	// A lookup key used to retrieve prices dynamically from a static string.
	// +kubebuilder:validation:Optional
	LookupKey *string `json:"lookupKey,omitempty" tf:"lookup_key,omitempty"`

	// Map(String). Set of key-value pairs that you can attach to an object. This can be useful for
	// storing additional information about the object in a structured format.
	// Set of key-value pairs that you can attach to an object. This can be useful for storing additional information about the object in a structured format.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// String. A brief description of the price, hidden from customers.
	// A brief description of the price, hidden from customers.
	// +kubebuilder:validation:Optional
	Nickname *string `json:"nickname,omitempty" tf:"nickname,omitempty"`

	// String. The ID of the product that this price will belong to.
	// The ID of the product that this price will belong to.
	// +kubebuilder:validation:Optional
	Product *string `json:"product,omitempty" tf:"product,omitempty"`

	// List(Resource). The recurring components of a price such as interval and usage_type. For
	// details of individual arguments see Recurring.
	// The recurring components of a price such as interval and usage_type.
	// +kubebuilder:validation:Optional
	Recurring []RecurringParameters `json:"recurring,omitempty" tf:"recurring,omitempty"`

	// String. Specifies whether the price is considered inclusive of taxes or exclusive of
	// taxes. One of inclusive, exclusive, or unspecified. Once specified as either inclusive or exclusive, it
	// cannot be changed, default is unspecified.
	// Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of inclusive, exclusive, or unspecified. Once specified as either inclusive or exclusive, it cannot be changed.
	// +kubebuilder:validation:Optional
	TaxBehavior *string `json:"taxBehavior,omitempty" tf:"tax_behavior,omitempty"`

	// List(Resource). Each element represents a pricing tier. This parameter requires billing_scheme
	// to be set to tiered. See also the documentation for billing_scheme. For details of individual arguments
	// see Tiers.
	// Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered. See also the documentation for billing_scheme.
	// +kubebuilder:validation:Optional
	Tiers []PriceTiersParameters `json:"tiers,omitempty" tf:"tiers,omitempty"`

	// String. Defines if the tiering price should be graduated
	// or volume based. In volume-based tiering, the maximum quantity within a period determines the per-unit price,
	// in graduated tiering pricing can successively change as the quantity grows.
	// Defines if the tiering price should be graduated or volume based. In volume-based tiering, the maximum quantity within a period determines the per unit price, in graduated tiering pricing can successively change as the quantity grows.
	// +kubebuilder:validation:Optional
	TiersMode *string `json:"tiersMode,omitempty" tf:"tiers_mode,omitempty"`

	// Bool. If set to true, will atomically remove the lookup key from the existing
	// price, and assign it to this price.
	// If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
	// +kubebuilder:validation:Optional
	TransferLookupKey *bool `json:"transferLookupKey,omitempty" tf:"transfer_lookup_key,omitempty"`

	// List(Resource). Apply a transformation to the reported usage or set quantity before
	// computing the billed price. Cannot be combined with tiers. For details of individual arguments
	// see Transform Quantity.
	// Apply a transformation to the reported usage or set quantity before computing the billed price. Cannot be combined with tiers
	// +kubebuilder:validation:Optional
	TransformQuantity []TransformQuantityParameters `json:"transformQuantity,omitempty" tf:"transform_quantity,omitempty"`

	// Int. A positive integer in cents (or -1 for a free
	// price) representing how much to charge.
	// A positive integer in cents (or -1 for a free price) representing how much to charge.
	// +kubebuilder:validation:Optional
	UnitAmount *float64 `json:"unitAmount,omitempty" tf:"unit_amount,omitempty"`

	// Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
	// decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	// Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set
	// +kubebuilder:validation:Optional
	UnitAmountDecimal *float64 `json:"unitAmountDecimal,omitempty" tf:"unit_amount_decimal,omitempty"`
}

type PriceTiersInitParameters struct {

	// Int. The flat billing amount for an entire tier, regardless of the number of units in the
	// tier.
	// The flat billing amount for an entire tier, regardless of the number of units in the tier.
	FlatAmount *float64 `json:"flatAmount,omitempty" tf:"flat_amount,omitempty"`

	// Float. Same as flat_amount, but accepts a decimal value representing an integer
	// in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
	// Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
	FlatAmountDecimal *float64 `json:"flatAmountDecimal,omitempty" tf:"flat_amount_decimal,omitempty"`

	// Int. A positive integer in cents (or -1 for a free
	// price) representing how much to charge.
	// The per unit billing amount for each individual unit for which this tier applies.
	UnitAmount *float64 `json:"unitAmount,omitempty" tf:"unit_amount,omitempty"`

	// Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
	// decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	// Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	UnitAmountDecimal *float64 `json:"unitAmountDecimal,omitempty" tf:"unit_amount_decimal,omitempty"`

	// Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
	// previous tier adding one. Use -1 to define a fallback tier.
	// Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
	UpTo *float64 `json:"upTo,omitempty" tf:"up_to,omitempty"`
}

type PriceTiersObservation struct {

	// Int. The flat billing amount for an entire tier, regardless of the number of units in the
	// tier.
	// The flat billing amount for an entire tier, regardless of the number of units in the tier.
	FlatAmount *float64 `json:"flatAmount,omitempty" tf:"flat_amount,omitempty"`

	// Float. Same as flat_amount, but accepts a decimal value representing an integer
	// in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
	// Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
	FlatAmountDecimal *float64 `json:"flatAmountDecimal,omitempty" tf:"flat_amount_decimal,omitempty"`

	// Int. A positive integer in cents (or -1 for a free
	// price) representing how much to charge.
	// The per unit billing amount for each individual unit for which this tier applies.
	UnitAmount *float64 `json:"unitAmount,omitempty" tf:"unit_amount,omitempty"`

	// Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
	// decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	// Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	UnitAmountDecimal *float64 `json:"unitAmountDecimal,omitempty" tf:"unit_amount_decimal,omitempty"`

	// Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
	// previous tier adding one. Use -1 to define a fallback tier.
	// Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
	UpTo *float64 `json:"upTo,omitempty" tf:"up_to,omitempty"`
}

type PriceTiersParameters struct {

	// Int. The flat billing amount for an entire tier, regardless of the number of units in the
	// tier.
	// The flat billing amount for an entire tier, regardless of the number of units in the tier.
	// +kubebuilder:validation:Optional
	FlatAmount *float64 `json:"flatAmount,omitempty" tf:"flat_amount,omitempty"`

	// Float. Same as flat_amount, but accepts a decimal value representing an integer
	// in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
	// Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
	// +kubebuilder:validation:Optional
	FlatAmountDecimal *float64 `json:"flatAmountDecimal,omitempty" tf:"flat_amount_decimal,omitempty"`

	// Int. A positive integer in cents (or -1 for a free
	// price) representing how much to charge.
	// The per unit billing amount for each individual unit for which this tier applies.
	// +kubebuilder:validation:Optional
	UnitAmount *float64 `json:"unitAmount,omitempty" tf:"unit_amount,omitempty"`

	// Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
	// decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	// Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	// +kubebuilder:validation:Optional
	UnitAmountDecimal *float64 `json:"unitAmountDecimal,omitempty" tf:"unit_amount_decimal,omitempty"`

	// Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
	// previous tier adding one. Use -1 to define a fallback tier.
	// Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
	// +kubebuilder:validation:Optional
	UpTo *float64 `json:"upTo,omitempty" tf:"up_to,omitempty"`
}

type RecurringInitParameters struct {

	// String. Specifies a usage of aggregation strategy for prices of usage_type=metered.
	// Allowed values are sum for summing up all usage during a period, last_during_period for using the last usage
	// record reported within a period, last_ever for using the last usage record ever (across period bounds) or max
	// which uses the usage record with the maximum reported usage during a period.
	// Specifies a usage aggregation strategy for prices of usage_type=metered. Allowed values are sum for summing up all usage during a period, last_during_period for using the last usage record reported within a period, last_ever for using the last usage record ever (across period bounds) or max which uses the usage record with the maximum reported usage during a period.
	AggregateUsage *string `json:"aggregateUsage,omitempty" tf:"aggregate_usage,omitempty"`

	// String. Specifies billing frequency. Either day, week, month or year.
	// Specifies billing frequency. Either day, week, month or year.
	Interval *string `json:"interval,omitempty" tf:"interval,omitempty"`

	// Int. This parameter is  when interval value is set. The number of intervals between subscription billings. For
	// example, interval=month and interval_count=3 bills every 3 months. Maximum of one year interval allowed (1 year,
	// 12 months, or 52 weeks).
	// The number of intervals between subscription billings. For example, interval=month and interval_count=3 bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
	IntervalCount *float64 `json:"intervalCount,omitempty" tf:"interval_count,omitempty"`

	// String. The meter tracking the usage of a metered price.
	// The meter tracking the usage of a metered price
	Meter *string `json:"meter,omitempty" tf:"meter,omitempty"`

	// String. Configures how the quantity per period should be determined. Can be either metered
	// or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates
	// the total usage based on usage records. Defaults to licensed.
	// Configures how the quantity per period should be determined. Can be either metered or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates the total usage based on usage records. Defaults to licensed.
	UsageType *string `json:"usageType,omitempty" tf:"usage_type,omitempty"`
}

type RecurringObservation struct {

	// String. Specifies a usage of aggregation strategy for prices of usage_type=metered.
	// Allowed values are sum for summing up all usage during a period, last_during_period for using the last usage
	// record reported within a period, last_ever for using the last usage record ever (across period bounds) or max
	// which uses the usage record with the maximum reported usage during a period.
	// Specifies a usage aggregation strategy for prices of usage_type=metered. Allowed values are sum for summing up all usage during a period, last_during_period for using the last usage record reported within a period, last_ever for using the last usage record ever (across period bounds) or max which uses the usage record with the maximum reported usage during a period.
	AggregateUsage *string `json:"aggregateUsage,omitempty" tf:"aggregate_usage,omitempty"`

	// String. Specifies billing frequency. Either day, week, month or year.
	// Specifies billing frequency. Either day, week, month or year.
	Interval *string `json:"interval,omitempty" tf:"interval,omitempty"`

	// Int. This parameter is  when interval value is set. The number of intervals between subscription billings. For
	// example, interval=month and interval_count=3 bills every 3 months. Maximum of one year interval allowed (1 year,
	// 12 months, or 52 weeks).
	// The number of intervals between subscription billings. For example, interval=month and interval_count=3 bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
	IntervalCount *float64 `json:"intervalCount,omitempty" tf:"interval_count,omitempty"`

	// String. The meter tracking the usage of a metered price.
	// The meter tracking the usage of a metered price
	Meter *string `json:"meter,omitempty" tf:"meter,omitempty"`

	// String. Configures how the quantity per period should be determined. Can be either metered
	// or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates
	// the total usage based on usage records. Defaults to licensed.
	// Configures how the quantity per period should be determined. Can be either metered or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates the total usage based on usage records. Defaults to licensed.
	UsageType *string `json:"usageType,omitempty" tf:"usage_type,omitempty"`
}

type RecurringParameters struct {

	// String. Specifies a usage of aggregation strategy for prices of usage_type=metered.
	// Allowed values are sum for summing up all usage during a period, last_during_period for using the last usage
	// record reported within a period, last_ever for using the last usage record ever (across period bounds) or max
	// which uses the usage record with the maximum reported usage during a period.
	// Specifies a usage aggregation strategy for prices of usage_type=metered. Allowed values are sum for summing up all usage during a period, last_during_period for using the last usage record reported within a period, last_ever for using the last usage record ever (across period bounds) or max which uses the usage record with the maximum reported usage during a period.
	// +kubebuilder:validation:Optional
	AggregateUsage *string `json:"aggregateUsage,omitempty" tf:"aggregate_usage,omitempty"`

	// String. Specifies billing frequency. Either day, week, month or year.
	// Specifies billing frequency. Either day, week, month or year.
	// +kubebuilder:validation:Optional
	Interval *string `json:"interval" tf:"interval,omitempty"`

	// Int. This parameter is  when interval value is set. The number of intervals between subscription billings. For
	// example, interval=month and interval_count=3 bills every 3 months. Maximum of one year interval allowed (1 year,
	// 12 months, or 52 weeks).
	// The number of intervals between subscription billings. For example, interval=month and interval_count=3 bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
	// +kubebuilder:validation:Optional
	IntervalCount *float64 `json:"intervalCount,omitempty" tf:"interval_count,omitempty"`

	// String. The meter tracking the usage of a metered price.
	// The meter tracking the usage of a metered price
	// +kubebuilder:validation:Optional
	Meter *string `json:"meter,omitempty" tf:"meter,omitempty"`

	// String. Configures how the quantity per period should be determined. Can be either metered
	// or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates
	// the total usage based on usage records. Defaults to licensed.
	// Configures how the quantity per period should be determined. Can be either metered or licensed. licensed automatically bills the quantity set when adding it to a subscription. metered aggregates the total usage based on usage records. Defaults to licensed.
	// +kubebuilder:validation:Optional
	UsageType *string `json:"usageType,omitempty" tf:"usage_type,omitempty"`
}

type TiersInitParameters struct {

	// Int. The flat billing amount for an entire tier, regardless of the number of units in the
	// tier.
	// The flat billing amount for an entire tier, regardless of the number of units in the tier.
	FlatAmount *float64 `json:"flatAmount,omitempty" tf:"flat_amount,omitempty"`

	// Float. Same as flat_amount, but accepts a decimal value representing an integer
	// in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
	// Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
	FlatAmountDecimal *float64 `json:"flatAmountDecimal,omitempty" tf:"flat_amount_decimal,omitempty"`

	// Int. A positive integer in cents (or -1 for a free
	// price) representing how much to charge.
	// The per unit billing amount for each individual unit for which this tier applies.
	UnitAmount *float64 `json:"unitAmount,omitempty" tf:"unit_amount,omitempty"`

	// Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
	// decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	// Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	UnitAmountDecimal *float64 `json:"unitAmountDecimal,omitempty" tf:"unit_amount_decimal,omitempty"`

	// Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
	// previous tier adding one. Use -1 to define a fallback tier.
	// Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
	UpTo *float64 `json:"upTo,omitempty" tf:"up_to,omitempty"`
}

type TiersObservation struct {

	// Int. The flat billing amount for an entire tier, regardless of the number of units in the
	// tier.
	// The flat billing amount for an entire tier, regardless of the number of units in the tier.
	FlatAmount *float64 `json:"flatAmount,omitempty" tf:"flat_amount,omitempty"`

	// Float. Same as flat_amount, but accepts a decimal value representing an integer
	// in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
	// Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
	FlatAmountDecimal *float64 `json:"flatAmountDecimal,omitempty" tf:"flat_amount_decimal,omitempty"`

	// Int. A positive integer in cents (or -1 for a free
	// price) representing how much to charge.
	// The per unit billing amount for each individual unit for which this tier applies.
	UnitAmount *float64 `json:"unitAmount,omitempty" tf:"unit_amount,omitempty"`

	// Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
	// decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	// Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	UnitAmountDecimal *float64 `json:"unitAmountDecimal,omitempty" tf:"unit_amount_decimal,omitempty"`

	// Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
	// previous tier adding one. Use -1 to define a fallback tier.
	// Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
	UpTo *float64 `json:"upTo,omitempty" tf:"up_to,omitempty"`
}

type TiersParameters struct {

	// Int. The flat billing amount for an entire tier, regardless of the number of units in the
	// tier.
	// The flat billing amount for an entire tier, regardless of the number of units in the tier.
	// +kubebuilder:validation:Optional
	FlatAmount *float64 `json:"flatAmount,omitempty" tf:"flat_amount,omitempty"`

	// Float. Same as flat_amount, but accepts a decimal value representing an integer
	// in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
	// Same as flat_amount, but accepts a decimal value representing an integer in the minor units of the currency. Only one of flat_amount and flat_amount_decimal can be set.
	// +kubebuilder:validation:Optional
	FlatAmountDecimal *float64 `json:"flatAmountDecimal,omitempty" tf:"flat_amount_decimal,omitempty"`

	// Int. A positive integer in cents (or -1 for a free
	// price) representing how much to charge.
	// The per unit billing amount for each individual unit for which this tier applies.
	// +kubebuilder:validation:Optional
	UnitAmount *float64 `json:"unitAmount,omitempty" tf:"unit_amount,omitempty"`

	// Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
	// decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	// Same as unit_amount, but accepts a decimal value in cents with at most 12 decimal places. Only one of unit_amount and unit_amount_decimal can be set.
	// +kubebuilder:validation:Optional
	UnitAmountDecimal *float64 `json:"unitAmountDecimal,omitempty" tf:"unit_amount_decimal,omitempty"`

	// Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
	// previous tier adding one. Use -1 to define a fallback tier.
	// Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the previous tier adding one. Use -1 to define a fallback tier.
	// +kubebuilder:validation:Optional
	UpTo *float64 `json:"upTo,omitempty" tf:"up_to,omitempty"`
}

type TransformQuantityInitParameters struct {

	// Int. Divide usage by this number.
	// Divide usage by this number.
	DivideBy *float64 `json:"divideBy,omitempty" tf:"divide_by,omitempty"`

	// String. After division, either round the result up or down.
	// After division, either round the result up or down
	Round *string `json:"round,omitempty" tf:"round,omitempty"`
}

type TransformQuantityObservation struct {

	// Int. Divide usage by this number.
	// Divide usage by this number.
	DivideBy *float64 `json:"divideBy,omitempty" tf:"divide_by,omitempty"`

	// String. After division, either round the result up or down.
	// After division, either round the result up or down
	Round *string `json:"round,omitempty" tf:"round,omitempty"`
}

type TransformQuantityParameters struct {

	// Int. Divide usage by this number.
	// Divide usage by this number.
	// +kubebuilder:validation:Optional
	DivideBy *float64 `json:"divideBy" tf:"divide_by,omitempty"`

	// String. After division, either round the result up or down.
	// After division, either round the result up or down
	// +kubebuilder:validation:Optional
	Round *string `json:"round" tf:"round,omitempty"`
}

// PriceSpec defines the desired state of Price
type PriceSpec struct {
	v2.ManagedResourceSpec `json:",inline"`
	ForProvider            PriceParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider PriceInitParameters `json:"initProvider,omitempty"`
}

// PriceStatus defines the observed state of Price.
type PriceStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        PriceObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Price is the Schema for the Prices API. The Stripe Price can be created, modified and configured by this resource.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Namespaced,categories={crossplane,managed,stripe}
type Price struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.currency) || (has(self.initProvider) && has(self.initProvider.currency))",message="spec.forProvider.currency is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.product) || (has(self.initProvider) && has(self.initProvider.product))",message="spec.forProvider.product is a required parameter"
	Spec   PriceSpec   `json:"spec"`
	Status PriceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// PriceList contains a list of Prices
type PriceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Price `json:"items"`
}

// Repository type metadata.
var (
	Price_Kind             = "Price"
	Price_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Price_Kind}.String()
	Price_KindAPIVersion   = Price_Kind + "." + CRDGroupVersion.String()
	Price_GroupVersionKind = CRDGroupVersion.WithKind(Price_Kind)
)

func init() {
	SchemeBuilder.Register(&Price{}, &PriceList{})
}
